#include <string>
#include <sstream>
#include <iostream>
#include <vector>
#include <cstdio>
#include <node.h>
#include <v8.h>

using namespace std;
using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::Function;
using v8::Object;
using v8::String;
using v8::Value;
using v8::Number;
using v8::Array;
using v8::Handle;
using v8::MaybeLocal;
using v8::Exception;
using v8::Context;


class sexp {
	public:
		bool isList;
		bool needsEval;
		string atom;
		vector<sexp*> sexplist;

		sexp() {}

		sexp(string data, bool needsEval) {
			this->isList = false;
			this->atom = data;
			this->needsEval = needsEval;
		}

		sexp(string data): sexp(data, false) {};

		sexp(vector<sexp*> data) {
			this->isList = true;
			this->sexplist = data;
		}

		string to_string() {
			if (!isList) return atom;

			string x = string("[");
			for (unsigned long i = 0; i < sexplist.size(); i++) {
				x.append(sexplist[i]->to_string());
				if (i != sexplist.size() - 1) {
					x.append(", ");
				}
			}
			x.append("]");
			return x;
		}

		Local<Value> to_node_obj(Isolate* iso) {
			if (this->isList) {
				Local<Array> array = Array::New(iso, sexplist.size());
				for (unsigned long i = 0; i < sexplist.size(); i++) {
					array->Set(i, sexplist[i]->to_node_obj(iso));
				}
				return array;
			} else if (this->needsEval) {
				for (unsigned long i = 0; i < this->atom.length(); i++) {
					switch (this->atom[i]) {
						case '/':
						case '&':
						case '(':
						case ')':
						case '=':
						case '|':
						case '{':
						case '}':
						case '[':
						case ']':
						case '"':
						case '\'':
						case '\\':
						case ';':
						case '?':
						case ':':
							return v8::Null(iso);
						default:
							continue;
					}
				}

				Local<Context> ctx = iso->GetCurrentContext();
				Local<Object> curGlobal = ctx->Global();
				Local<Object> process = String::NewFromUtf8(
    				iso, "process", v8::NewStringType::kNormal).ToLocalChecked().As<Object>();
				
				Local<Value> proc = curGlobal->Get(process);
				curGlobal->Set(process, v8::Null(iso));

				Local<Object> evalString = String::NewFromUtf8(
    				iso, "eval", v8::NewStringType::kNormal).ToLocalChecked().As<Object>();
				Local<Value> command = String::NewFromUtf8(
					iso, this->atom.c_str(), v8::NewStringType::kNormal).ToLocalChecked().As<Value>();
				Local<Function> eval = curGlobal->Get(evalString).As<Function>();
				int argc = 1;
				Local<Value> argv[1];
				argv[0] = command; 
				MaybeLocal<Value> result = eval->Call(iso->GetCurrentContext(), curGlobal, argc, argv);

				curGlobal->Set(process, proc);
				if (result.IsEmpty()) {
					return v8::Null(iso);
				} else {
					return result.ToLocalChecked();
				}
			} else {
				Local<String> v8_atom = String::NewFromUtf8(iso, this->atom.c_str());
				return v8_atom;
			}
		}

		static void erase(sexp* p) {
			if (p->isList) {
				for (unsigned long i = 0; i < p->sexplist.size(); i++) {
					sexp::erase(p->sexplist[i]);
				}
			} 
			delete p;
		}
};



class sexp_builder {
	public:

		bool isList;
		bool needsEval;
		string atom;
		vector<sexp*> sexplist;

		sexp_builder() {}

		sexp_builder(bool isList, bool needsEval) {
			this->isList = isList;
			this->needsEval = needsEval;
		}

		void add_char(char c) {
			if (this->isList) return;
			this->atom += c;
		}

		void add_sexp(sexp* s) {
			if (!this->isList) return;
			this->sexplist.push_back(s);
		}

		sexp* to_sexp() {
			if (this->isList) {
				return new sexp(this->sexplist);
			} else {
				return new sexp(this->atom, this->needsEval);
			}
		}
};

class parser {
	public:
		sexp* parse(string);
};

sexp* error(string s) {
	sexp* first = new sexp("error");
	sexp* second = new sexp(s);

	vector<sexp*> v;
	v.push_back(first);
	v.push_back(second);

	return new sexp (v);
}

sexp* parser::parse(string s) {
	sexp_builder* stack[1024];
	int pointer = -1;
	bool quoted = false;
	bool escaped = false;
	bool hasAt = false;

	for (unsigned long i = 0; i < s.length(); i++) {
		char c = s[i];

		if (escaped || (quoted && c != '\"' && c != '\\')) {
			stack[pointer]->add_char(c);
			escaped = false;
			continue;
		}

		if (c == '@' && stack[pointer]->isList && i < s.length() - 1 && s[i+1] == '\"') {
			hasAt = true;
			continue;
		}

		if ((c == ' ' || c == '\n' || c == '\t' ||
			 c == '(' || c == ')') && 
			pointer >= 0 && !stack[pointer]->isList) {
				if (stack[pointer]->isList) continue;
				sexp* res = stack[pointer]->to_sexp();
				delete stack[pointer--];
				if (pointer >= 0) {
					stack[pointer]->add_sexp(res);
				} else if (i != s.length() - 1) {
						return error("Trailing characters");
				} else {
						return res;
				}
		}

		switch(c) {
			case ' ':
			case '\n':
			case '\t': {
				break;
			}
			case '\"': {
				if (quoted) {
					quoted = false;
					sexp* res = stack[pointer]->to_sexp();
					delete stack[pointer--];
					if (pointer >= 0) {
						stack[pointer]->add_sexp(res);
					} else if (i != s.length() - 1) {
						return error("Trailing characters");
					} else {
						return res;
					}
				} else {
					quoted = true;
					stack[++pointer] = new sexp_builder(false, hasAt);
					if (pointer >= 1024) {
						return error("Stack overflow!");
					}
					hasAt = false;
				}
				break;
			}
			case '(': {
				stack[++pointer] = new sexp_builder(true, false);
				if (pointer >= 1024) {
					return error("Stack overflow!");
				}
				break;
			}
			case ')': {
				sexp* res = stack[pointer]->to_sexp();
				delete stack[pointer--];
				if (pointer == -1) {
					if (i != s.length() - 1) {
						return error("Trailing characters");
					} else {
						return res;
					}
				}
				stack[pointer]->add_sexp(res);
				break;
			}
			case '\\': {
				if (quoted) {
					escaped = true;
				} else {
					return error("Unexpected character \\");
				}
				break;
			}
			default: {
				if (stack[pointer]->isList) {
					stack[++pointer] = new sexp_builder(false, false);
					if (pointer >= 1024) {
						return error("Stack overflow!");
					}
				}
				stack[pointer]->add_char(c);
			}
		}
	}

	return error("Mismatched parenthesis");
}

int main(int argc, char** argv) {
	parser p;
	fprintf(stderr, "%s\n", p.parse("(\"hello world\")")->to_string().c_str());
	fprintf(stderr, "Hello World\n");

	return 0;
}

void Parse(const FunctionCallbackInfo<Value>& args) {
	parser p;
	Isolate* isolate = args.GetIsolate();

	if (args.Length () != 1 || !args[0]->IsString()) {
		isolate->ThrowException(Exception::TypeError(
			String::NewFromUtf8(isolate, "Error: Expected string")));
		return;
	}

	Local<Context> context = isolate->GetCurrentContext();
	Local<String> input = args[0]->ToString(context).ToLocalChecked();

	String::Utf8Value result(isolate, input);

	sexp* s = p.parse(string(*result));
	args.GetReturnValue().Set(s->to_node_obj(isolate));
	sexp::erase(s);
}

void init(Local<Object> exports) {
	NODE_SET_METHOD(exports, "parse", Parse);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, init);