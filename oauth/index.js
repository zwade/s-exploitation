let express       = require("express");
let bodyParser    = require("body-parser");
let cookieSession = require("cookie-session");
let dbPromise     = require("./db")("moa");
let crypto        = require("crypto");
let fs            = require("mz/fs");
let nconf         = require("nconf"); 
let csp           = require("express-csp-header");
let { join }      = require("path");

let samoa = nconf.get("samoa") || "localhost:12345"
let updator = nconf.get("updator") || "localhost:23456"

let start = async (db) => {
	let privateKey = await fs.readFile(join(__dirname, "keys", "id_rsa"))
	let app = express();

	app.use(bodyParser.urlencoded());
	app.use(cookieSession({
		name: "session",
		secret: "This is a silly secret boi",
		httpOnly: false,
	}))

	app.use(csp({
		policies: {
			'script-src': [csp.NONCE, csp.EVAL, '\'strict-dynamic\'']
		}
	}));

	app.get("/:ANY?", async (req, res) => {
		let path = join(__dirname, "client", "index.html");
		let file = await fs.readFile(path);
		file = file.toString().replace(/\{\{nonce\}\}/g, req.nonce);
		res.send(file);
	})

	let encode = name => `"${name.replace(/\\/g, "\\\\").replace(/"/g, "\\\"")}"`
	let assert = val => val ? true : (() => { throw "Assertion Failed" })();

	app.post("/register", (req, res) => {
		if (!req.body.name || !req.body.email || !req.body.password || !req.body.color || !req.body.food || !req.body.submit) {
			res.status(401);
			res.send("Missing Form Data");
			return;
		}

		let { name, email, password, color, food } = req.body;

		db.moa.find({$or: [{name}, {email}]}).toArray()
			.then(data => {
				if (data.length > 0) return Promise.reject("Username or email already exists!");
				return Promise.resolve();
			}).then(() => {
				let hash = crypto.createHash('sha256');
				hash.update(req.body.password)
				let hashedPass = hash.digest("hex");
				let dbContents = {
						name,
						email,
						hashedPass,
						color,
						food
				}
				return db.moa.insert(dbContents)
			}).then(() => {
				req.session.id = {
					name, 
					email, 
					color, 
					food
				}
				res.redirect("/user")
			}).catch(e => {
				res.send({ error: e})
			})
		
	})

	app.post("/login", (req, res) => {
		if (!req.body.email|| !req.body.password) {
			res.status(401);
			res.send("Missing Form Data");
			return;
		}

		let { email, password } = req.body;

		let hash = crypto.createHash('sha256');
		hash.update(req.body.password);
		let hashedPass = hash.digest('hex');

		db.moa.find({email, hashedPass}).toArray()
			.then(u => {
				if (u.length == 0) {
					return Promise.reject("Invalid Credentials");
				}
				return u[0];
			}).then(({name, email, color, food}) => {
				req.session.id = {
					name,
					email,
					color,
					food
				}
				res.redirect("/user")
			}).catch(e => {
				res.send({error: e})
			})
	})


	app.post("/auth", (req, res) => {
		if (!req.session.id || !req.body.perm || !req.body.redirect) {
			res.status(401);
			res.send("Missing Form Data");
			return;
		}

		let { perm, redirect } = req.body;
		if (redirect.indexOf("?") < 0) {
			redirect = redirect + "?";
		} else {
			redirect = redirect + "&";
		}
		let { name, email, color, food } = req.session.id;

		let sexp = `((name ${encode(name)}) (email ${encode(email)}) (color ${perm.indexOf("color") >= 0 ? encode(color) : "null"}) (food ${perm.indexOf("food") >= 0 ? encode(food) : "null"}) (perm (${perm.join(" ")})))`;

		let encoded = (new Buffer(sexp)).toString("base64");

		let signer = crypto.createSign("SHA256");
		signer.update(sexp);
		let sig = signer.sign(privateKey);
		sig = new Buffer(sig).toString("base64");

		let token = `${encoded}.${sig}`;

		res.redirect(`${redirect}token=${encodeURIComponent(token)}`);
		
	})


	app.listen(12345, "0.0.0.0", () => 
		console.log(`Listening on 0.0.0.0:12345`))
}

dbPromise().then(start)

